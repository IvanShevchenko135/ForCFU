#include <cstdlib>
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;


char s[20000000];

void do_it(int l, int r, int k) {
    int step = (r - l + 1) / 3;

    if (l >= r || !k || !step){
	return;	
    } 

    for (int i = l + step; i <= r - step; i++){
	   s[i] = ' ';	
    } 
    k -= 1;
    do_it(l, l + step - 1, k);
    do_it(r - step + 1, r, k);
    return;
}

int main() {
	long long n, k;
	scanf("%lld%lld", &n, &k);
	for (long long i = 0; i < n; i++){
		s[i] = '#';	
	}
	s[n] = 0;
    do_it(0, n - 1, k);
    printf("%s", s);
    
    return 0;
}

/*
Ка?нторово мно?жество (канторов дисконтинуум, канторова пыль) — один из простейших фракталов, подмножество единичного отрезка вещественной прямой, которое является классическим примером дисконтинуума в математическом анализе. Описано в 1883 году Георгом Кантором.

Промоделируем канторово множество следующим образом. Заполним строку длины n = 3k символами '#', получим начальную строку. Например, если n = 27, то начальная строка будет иметь вид

###########################
На шаге номер 1 разобьем строку на три равные части и заполним среднюю часть пробелами, получим строку

#########         #########
На шаге номер 2 разобьем каждую из оставшихся сплошных подстрок на три равные части и заполним каждую среднюю часть пробелами, получим строку

###   ###         ###   ###
Аналогично, после шага номер 3 получим строку

# #   # #         # #   # #
Для n = 27 можно выполнить не более трех описанных выше шагов.

Напишите программу, которая по заданной длине исходной строки и по заданному количеству шагов алгоритма выведет получившуюся строку, моделирующую канторово множество. Для построения результирующей строки используйте рекурсивную функцию.
*/