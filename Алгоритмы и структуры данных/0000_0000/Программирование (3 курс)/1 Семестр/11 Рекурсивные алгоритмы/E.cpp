#define _CRT_SECURE_NO_WARNINGS 
#include <iostream>
#include <cstdlib>
#include <stdio.h> 
#include <math.h>
#include <iomanip> 
#include <cstring>
using namespace std;

long long fib[46];

char fibon(long long n, long long k){
	if(n == 0){
		return 'a';	
	}else if(n == 1){
		return 'b';
	}else{
		if(fib[n-2] < k){
			return fibon(n - 1, k - fib[n - 2]);
		}else{
			return fibon(n - 2, k);
		}
	}
}
int main() {
	fib[0] = 1;
	fib[1] = 1;
	for (int i = 2; i < 46; i++) {
		fib[i] = fib[i - 2] + fib[i - 1];
	}
	int T;
	scanf("%d", &T);
	while(T--){
		long long n, k;
		scanf("%lld%lld", &n, &k);
		printf("%c\n", fibon(n, k));
	}
	return 0;
}

/*
В математике достаточно часто применяются так называемые рекуррентные соотношения. Обычно они применяются для задания числовых последовательностей, но могут применяться и для задания последовательностей строк.

Одним из примеров строк, задаваемых рекуррентным соотношением, являются строки Фибоначчи F0 = a, F1 = b, ... . Они задаются следующим образом: F0 = a, F1 = b, Fi = Fi-2Fi-1, i > 1. Первые семь строк Фибоначчи выглядят следующим образом: a, b, ab, bab, abbab, bababbab, abbabbababbab.

Дима занимается в кружке олимпиадного программирования и интересуется алгоритмами на строках. Недавно он узнал о строках Фибоначчи. Он быстро понял, что их длина с увеличением номера n растет очень быстро, поэтому задача нахождения всех символов строки Fn требует слишком большого объема памяти. Поэтому он решил ограничиться задачей нахождения некоторых символов.

Напишите программу, которая находит k-ый символ строки Fn.
*/