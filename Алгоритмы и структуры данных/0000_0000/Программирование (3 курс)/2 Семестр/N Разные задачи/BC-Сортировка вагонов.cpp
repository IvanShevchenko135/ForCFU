#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <fstream> 
using namespace std;

int main() {
	int mass1[20000], mass2[20000], N, N2 = 0, N3;
	int posl[20000][2], iter = -1;
	bool flag = false;
	memset(mass1, 0, sizeof(mass1));
	memset(mass2, 0, sizeof(mass2));
	scanf("%d", &N);
	N3 = N;
	for (int i = 0; i < N; i++) {
		scanf("%d", &mass1[i]);
	}

	for (int i = 1; i <= N; i++) { //i — Счетчик переведенных элементов
		if ((N2 != 0) && (mass2[N2 - 1] == i)) {
			mass2[N2 - 1] = 0;
			N2--;
			if (posl[iter][0] == 2) {
				posl[iter][1]++;
			} else {
				posl[++iter][0] = 2;
				posl[iter][1] = 1;
			}
			//printf("2 1\n");
			continue;
		}
		else {
			flag = false;
			for (int j = 0; j < N; j++) {//j — Счетчик текущего(реального) массива. Ищем значение среди первого выезда.
				if (mass1[j + (N - N3)] == i) {
					for (int k = 0; k < j; k++) { //Загоняем вагоны в тупик
						mass2[N2 + k] = mass1[k + (N - N3)];
					}
					N2 += j;
					N3 -= (j + 1);
					//printf("1 %d\n", j + 1);
					if (posl[iter][0] == 1) {
						posl[iter][1] += (j + 1);
					}
					else {
						posl[++iter][0] = 1;
						posl[iter++][1] = (j + 1);
					}
					//printf("2 1\n");
					posl[iter][0] = 2;
					posl[iter][1] = 1;
					
					flag = true;
					break;
				}
			}
			if (!flag) {
				printf("0");
				return 0;
			}
			else {
				continue;
			}
		}
	}
	for (int i = 0; i <= iter; i++) {
		printf("%d %d\n", posl[i][0], posl[i][1]);
	}
	//system("pause");
	return 0;
}
/*
Љ тупику со стороны пути 1 (см. рисунок) подъехал поезд. ђазрешаетсЯ отцепить от поезда один или сразу несколько первых вагонов и завезти их в тупик (при желании, можно даже завезти в тупик сразу весь поезд). Џосле этого часть из этих вагонов вывезти в сторону пути 2. Џосле этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихсЯ вагонов вывезти в сторону пути 2. € так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2). ‡аезжать вагонам в тупик с пути 2 или выезжать из тупика на путь 1 запрещаетсЯ. ЌельзЯ с пути 1 попасть на путь 2, не заезжаЯ в тупик.

€звестно, в каком порЯдке изначально идут вагоны поезда. ’ребуетсЯ с помощью указанных операций сделать так, чтобы вагоны поезда шли по порЯдку (сначала первый, потом второй и т.д., считаЯ от головы поезда, едущего по пути 2 в сторону от тупика).

”ормат входных данных
‚водитсЯ число N С количество вагонов в поезде (1 І N І 2000). „альше идут номера вагонов в порЯдке от головы поезда, едущего по пути 1 в сторону тупика. ‚агоны пронумерованы натуральными числами от 1 до N, каждое из которых встречаетсЯ ровно один раз.

”ормат результата
…сли сделать так, чтобы вагоны шли в порЯдке от 1 до N, считаЯ от головы поезда, когда поезд поедет по пути 2 из тупика, можно, выведите действиЯ, которые нужно проделать с поездом. Љаждое действие описываетсЯ двумЯ числами: типом и количеством вагонов:

если нужно завезти с пути 1 в тупик K вагонов, должно быть выведено сначала число 1, а затем С число K (K і 1),
если нужно вывезти из тупика на путь 2 K вагонов, должно быть выведено сначала число 2, а затем С число K (K і 1).
…сли возможно несколько последовательностей действий, приводЯщих к нужному результату, выведите любую из них.

…сли выстроить вагоны по порЯдку невозможно, выведите одно число 0.
*/