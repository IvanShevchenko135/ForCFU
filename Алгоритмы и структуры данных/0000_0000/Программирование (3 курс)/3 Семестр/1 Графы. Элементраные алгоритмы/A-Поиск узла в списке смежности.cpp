#define _CRT_SECURE_NO_WARNINGS 
#include <iostream> 
#include <cstdlib> 
#include <stdio.h> 
#include <string> 
#include <set> 
#include <fstream> 
#include <algorithm> 
#include <math.h> 
#include <queue> 
#include <iterator> 
#include <map>
using namespace std;

vector <int> g[200000];
int gi[200000];

int sear(int a, int vi, int vg) {
	int l = 0, r = vi - 1;
	while (l <= r) {
		if (g[vg][(l + r) / 2] == a) {
			return ((l + r) / 2) + 1;
		}
		else if ((g[vg][(l + r)/ 2]) < a) {
			l = (l + r) / 2 + 1;
		}
		else {
			r = (l + r) / 2 - 1;
		}
	}
	return 0;
}
int main() {
	int v, u;
	int N, M;
	int Q;
	scanf("%d%d", &N, &M);
	while (M--) {
		scanf("%d%d", &v, &u);
		g[v].push_back(u);
		g[u].push_back(v);
		gi[v]++;
		gi[u]++;
	}
	for (int i = 0; i <= N; i++) {
		if (gi[i] != 0) {
			sort(g[i].begin(), g[i].end());
		}
	}
	scanf("%d", &Q);
	while (Q--) {
		scanf("%d%d", &v, &u);
		if (gi[v] != 0) {
			printf("%d\n", sear(u, gi[v], v));
		}
		else {
			printf("0\n");
		}
	}

	return 0;
}
/*
Поиск узла в списке смежности
Дан неориентированный граф из N узлов и M ребер, не содержащий петель и кратных ребер. Напишите программу, которая обрабатывает Q запросов. Каждый запрос содержит два натуральных числа a и b - номера узлов. Программа должна выводить порядковый номер узла b в списке смежности для узла a, если расположить все узлы списка смежности для узла a по возрастанию их номеров. Считать, что узлы в отсортированном списке смежности нумеруются с 1. Если узла b в списке смежности для узла a нет, программа должна вывести 0.

Формат входных данных
В первой строке входных данных содержатся два натуральных числа N (1 ≤ N ≤ 105) и M (1 ≤ M ≤ 105).

В следущих M строках содержатся пары натуральных чисел a и b, разделенных пробелом - номера узлов, соединенных ребром (1 ≤ a,b ≤ N, a ≠ b).

В следующей строке задано количество запросов Q (1 ≤ Q ≤ 105).

В каждой из последующих Q строк содержаться два натуральных числа X и Y (1 ≤ X,Y ≤ N, X ≠ Y).

Формат результата
Для каждой пары чисел X и Y выведите в отдельную строку порядковый номер узла Y в списке смежности для узла X, если отсортировать все узлы списка смежности для узла X по возрастанию номеров. Если узла Y в списке смежности для узла X нет, выведите 0.

Примеры
Входные данные
5 4
1 2
1 5
4 1
3 1
3
1 4
2 1
3 4
Результат работы
3
1
0
*/