#define _CRT_SECURE_NO_WARNINGS 
#include <iostream> 
#include <cstdlib> 
#include <stdio.h> 
#include <vector> 
#include <set> 
#include <fstream> 
#include <algorithm> 
#include <math.h> 
#include <queue> 
#include <iterator> 
using namespace std;

long long g[61][61][61]; //[ctep][w][to]

int main() {
	int k;
	int a, b;
	int n = 0;
	scanf("%d", &k);
	while (k--) {
		scanf("%d%d", &a, &b);
		g[1][a][b] = 1;
		g[0][a][b] = 1;
		if (n < a) n = a;
		if (n < b) n = b;
	}
	n++;
	for (int k = 2; k < 61; k++) {
		for (int j = 0; j < 61; j++) {
			for (int i = 0; i < 61; i++) {
				for (int p = 0; p < 61; p++) {
					g[k][i][j] += g[k - 1][i][p] * g[1][p][j];
				}
				if (k > 29 && g[k][i][j] != 0 || g[0][i][j] == -1) {
					g[0][i][j] = -1;
				}
				else {
					g[0][i][j] += g[k][i][j];
				}
			}
		}
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			printf("%lld ", g[0][i][j]);
		}
		printf("\n");
	}
	return 0;
}
/*
Количество путей между всеми парами узлов
Перекрестки в городе соединены односторонними дорогами. Напишите программу, которая вычисляет количество разных путей между каждой парой перекрестков. Путем называется последовательность односторонних дорог, соединяющих перекрестки.

Перекрестки обозначаются неотрицательными целыми числами. Односторонняя дорога обозначается парой перекрестков, которые она соединяет. Например, пара j k указывает на то, что односторонняя дорога идет от перекрестка j к перекрестку k. Заметим, что двусторонняя дорога может быть промоделирована двумя односторонними: j k и k j.

Рассмотрим город с четырьмя перекрестками, которые соединены улицами следующим образом:

0 1
0 2
1 2
2 3
Существует только один путь между перекрестками 0 и 1, два пути между 0 и 2 (это 0->1->2 и 0->2), два пути между 0 и 3, один путь между 1 и 2, один путь между 1 и 3, один путь между 2 и 3, других путей не существует.

Возможно, между некоторыми перекрестками существует бесконечное количество путей. Например, если к описанному выше множеству дорог добавить 3 2, между 0 и 1 останется один путь, но появится бесконечное количество путей между 0 и 2. Потому что из 2 в 3 и назад из 3 в 2 можно двигаться произвольное количество раз, получая бесконечное количество разных путей. То есть пути 0->2->3->2->3->2 и 0->2->3->2 разные.

Формат входных данных
Первое число входных данных - количество односторонних улиц в городе. Далее следует их описание.

Каждая улица задается парой перекрестков, которые она соединяет - каждая пара j k представляет собой одностороннюю улицу от перекрестка j до перекрестка k. Во всех городах перекрестки последовательно пронумерованы от 0 до "наибольшего" перекрестка. Все входные целые числа разделены пробелами и переводами строк.

Ни одна из односторонних улиц не ведет от перекрестка к нему же самому. Ни один из городов не имеет больше 30 перекрестков. В городе есть хотя бы одна улица.

Формат результата
Выведите квадратную матрицу, содержащую информацию о количестве разных путей между всеми парами перекрестков. Если обозначить выводимую матрицу через M, то M[j][k] - это количество разных путей, ведущих от перекрестка j к перекрестку k.

Если между двумя перекрестками существует бесконечное количество путей, в матрице необходимо вывести -1.

Примеры
Входные данные
7 0 1 0 2 0 4 2 4 2 3 3 1 4 3
Результат работы
0 4 1 3 2
0 0 0 0 0
0 2 0 2 1
0 1 0 0 0
0 1 0 1 0
Входные данные
9
0 1 0 2 0 3
0 4 1 4 2 1
2 0
3 0
3 1
Результат работы
-1 -1 -1 -1 -1
0 0 0 0 1
-1 -1 -1 -1 -1
-1 -1 -1 -1 -1
0 0 0 0 0
*/