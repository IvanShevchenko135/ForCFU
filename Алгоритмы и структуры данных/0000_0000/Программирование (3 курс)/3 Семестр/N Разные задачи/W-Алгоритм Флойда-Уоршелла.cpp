#define _CRT_SECURE_NO_WARNINGS 
#include <iostream> 
#include <cstdlib> 
#include <stdio.h> 
#include <vector> 
#include <set> 
#include <fstream> 
#include <algorithm> 
#include <math.h> 
#include <queue> 
#include <iterator> 
using namespace std;



int main() {
	int T;
	scanf("%d", &T);
	while (T--) {
		int N, M;
		int D[101][101];
		int a, b;
		int Q;
		scanf("%d%d", &N, &M);
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if (i == j) {
					D[i][j] = 1;
				}
				else {
					D[i][j] = -1;
				}
			}
		}

		while (M--) {
			scanf("%d%d", &a, &b);
			D[a - 1][b - 1] = 1;
			D[b - 1][a - 1] = 1;
		}


		for (int k = 0; k < N; k++) {
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					if (D[i][k] == 1 && D[k][j] == 1) {
						D[i][j] = 1;
						D[j][i] = 1;
					}
				}
			}
		}

		scanf("%d", &Q);
		while (Q--) {
			scanf("%d%d", &a, &b);
			if (D[a - 1][b - 1] == -1) {
				printf("0\n");
			}
			else {
				printf("1\n");
			}
		}

	}
	//system("pause");
	return 0;
}
/*
Задача W: Алгоритм Флойда-Уоршелла
Дан неориентированный граф. Необходимо выяснить, есть ли путь из узла с номером I в узел с номером J.

Input
Первая строка стандартного потока ввода содержит количество тестовых случаев Т.

Каждый тестовый случай состоит из нескольких строк.

Первая строка содержит два натуральных числа N, M, разделенных пробелом — количество узлов графа и количество ребер (1 ≤ N ≤ 100, 1 ≤ M ≤ N*(N-1)/2).

Следующие M строк содержат по два целых числа Ai, Bi, разделенных пробелом — это номера узлов, которые соединенных ребром. (1 ≤ Ai, Bi ≤ N).

В следующей строке содержится натуральное число Q - количество запросов.

В следующих Q строках содежатся запросы - два целых числа Ii, Ji, разделенных пробелом. Это номера узлов, для которых необходимо выяснить, если ли путь, их соединяющий.

Output
Для каждого тестового случая выведите ровно Q строк. В каждой строке ответ на соответствующий запрос: 1 - если есть путь, связывающий узлы, и 0 - в противном случае.

Примеры
Входные данные
3
4 6
1 2
1 3
1 4
2 3
2 4
3 4
1
2 3
5 3
1 4
2 3
3 5
5
3 1
4 3
3 3
4 5
2 3
5 3
1 3
1 4
3 4
2
4 4
5 4
Результат работы
1
0
0
1
0
1
1
0
*/